@page "/admin/creditlimits"
@using BettingApp.Data
@using Microsoft.EntityFrameworkCore
@using Microsoft.AspNetCore.Authorization
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.AspNetCore.SignalR
@using System.Globalization
@using BettingApp.Hubs
@attribute [Authorize]
@inject IDbContextFactory<ApplicationDbContext> DbFactory
@inject AuthenticationStateProvider AuthStateProvider
@inject IJSRuntime JSRuntime
@inject NavigationManager Nav
@inject IHubContext<BetHub> HubContext
@rendermode InteractiveServer
@implements IAsyncDisposable

<h3>Credit/Payout Limits</h3>

@* --- PERSISTENT NOTIFICATION AREA --- *@
@if (!string.IsNullOrEmpty(successMessage))
{
    <div class="alert alert-success alert-dismissible fade show" role="alert">
        <i class="bi bi-check-circle-fill me-2"></i> @successMessage
        <button type="button" class="btn-close" @onclick="() => successMessage = null"></button>
    </div>
}

@if (!isAdmin)
{
    <p>You are not authorized to view this page.</p>
}
else if (users == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <div class="row mb-3">
        <div class="col-md-6">
            <div class="input-group">
                <span class="input-group-text">Search User</span>
                <input type="text" class="form-control" placeholder="Username..." 
                     @bind="searchTerm" @bind:event="oninput" />
            </div>
        </div>
    </div>

    <div class="table-responsive">
        <table class="table table-sm table-striped table-hover align-middle text-nowrap">
            <thead class="table-dark">
                <tr>
                    <th>Last Updated</th>
                    <th>First Name</th>
                    <th>Last Name</th>
                    <th>User</th>
                    <th>Credit Limit (NOK)</th>
                    <th>Max Payout (NOK)</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var user in FilteredUsers)
                {
                    @* FIX: We use a custom dictionary 'rowKeys' to force the row to re-render 
                       if the user clicks Cancel. This ensures the input box reverts visually.
                    *@
                    <tr @key="GetRowKey(user.Id)">
                        <td>@ToUserLocal(user.UpdatedAt).ToString("g")</td>
                        <td>@user.FirstName</td>
                        <td>@user.LastName</td>
                        <td>@user.UserName</td>
                        <td>
                            <input type="text" class="form-control form-control-sm" style="width: 150px;"
                                   value="@user.CreditLimit.ToString("N0")"
                                   @onchange="@(async (e) => await UpdateLimit(user, e.Value?.ToString(), isCredit: true))" />
                        </td>
                        <td>
                            <input type="text" class="form-control form-control-sm" style="width: 150px;"
                                   value="@user.MaxPayout.ToString("N0")"
                                   @onchange="@(async (e) => await UpdateLimit(user, e.Value?.ToString(), isCredit: false))" />
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    </div>
}

@code {
    private List<ApplicationUser>? users;
    private string searchTerm = "";
    private bool isAdmin = false;
    private string? successMessage; 
    private string? currentAdminName;
    private int TimezoneOffset { get; set; }
    private HubConnection? hubConnection;

    // FIX: Dictionary to track unique render keys for rows to handle "Cancel" revert
    private Dictionary<string, Guid> rowKeys = new();

    private IEnumerable<ApplicationUser> FilteredUsers => 
        string.IsNullOrWhiteSpace(searchTerm) 
            ? users ?? new List<ApplicationUser>() 
            : (users ?? new List<ApplicationUser>()) 
                .Where(u => u.UserName != null && 
                            u.UserName.Contains(searchTerm, StringComparison.OrdinalIgnoreCase));

    private Guid GetRowKey(string userId)
    {
        if (!rowKeys.ContainsKey(userId))
        {
            rowKeys[userId] = Guid.NewGuid();
        }
        return rowKeys[userId];
    }

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;
        currentAdminName = user.Identity?.Name;

        if (user.Identity?.IsAuthenticated == true)
        {
            using var context = DbFactory.CreateDbContext();
            var currentUser = await context.Users
                .AsNoTracking()
                .FirstOrDefaultAsync(u => u.UserName == user.Identity.Name);
            isAdmin = currentUser?.IsAdmin ?? false;
        }

        if (isAdmin)
        {
            await LoadUsers();
        }
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && isAdmin)
        {
            try {
                TimezoneOffset = await JSRuntime.InvokeAsync<int>("getBrowserTimeZoneOffset");
                await SetupSignalR();
                StateHasChanged();
            } catch { }
        }
    }
    
    private async Task SetupSignalR()
    {
        hubConnection = new HubConnectionBuilder()
            .WithUrl(Nav.ToAbsoluteUri("/bethub"))
            .Build();
        hubConnection.On<string>("ReceiveAdminNotification", async (message) =>
        {
            await LoadUsers();
            await InvokeAsync(StateHasChanged);
        });
        await hubConnection.StartAsync();
        await hubConnection.InvokeAsync("JoinAdminGroup");
    }

    private DateTime ToUserLocal(DateTime utcDate)
    {
        if (utcDate == DateTime.MinValue) return utcDate;
        return utcDate.AddMinutes(-TimezoneOffset);
    }

    private async Task LoadUsers()
    {
        using var context = DbFactory.CreateDbContext();
        users = await context.Users
            .Where(u => !u.IsAdmin)
            .OrderByDescending(u => u.UpdatedAt)
            .ToListAsync();
    }

    private async Task UpdateLimit(ApplicationUser userToUpdate, string? newValueStr, bool isCredit)
    {
        // 1. Parse the new value
        decimal newValue = 0;
        var cleanStr = newValueStr?.Replace(" ", "").Replace("\u00A0", ""); 
        
        bool isValid = decimal.TryParse(cleanStr, NumberStyles.Any, CultureInfo.InvariantCulture, out newValue);

        if (!isValid)
        {
            // Invalid number: force revert by changing key
            rowKeys[userToUpdate.Id] = Guid.NewGuid();
            StateHasChanged();
            return;
        }

        // 2. Pop-up Confirmation
        string fieldName = isCredit ? "Credit Limit" : "Max Payout";
        string msg = $"Are you sure you want to change {userToUpdate.UserName}'s {fieldName} to {newValue:N0} NOK?";
        
        bool confirmed = await JSRuntime.InvokeAsync<bool>("confirm", msg);

        if (!confirmed)
        {
            // FIX: Update the key to force the row to re-render with the ORIGINAL value
            rowKeys[userToUpdate.Id] = Guid.NewGuid();
            StateHasChanged();
            return;
        }

        // 3. Save Changes
        using var context = DbFactory.CreateDbContext();
        var dbUser = await context.Users.FindAsync(userToUpdate.Id);
        
        if (dbUser != null)
        {
            string logDetails = "";

            if (isCredit)
            {
                var oldVal = dbUser.CreditLimit;
                dbUser.CreditLimit = (int)newValue;
                logDetails = $"CreditLimit: {oldVal:N0} -> {dbUser.CreditLimit:N0}";
            }
            else
            {
                var oldVal = dbUser.MaxPayout;
                dbUser.MaxPayout = newValue;
                logDetails = $"MaxPayout: {oldVal:N0} -> {dbUser.MaxPayout:N0}";
            }
            
            dbUser.UpdatedAt = DateTime.UtcNow; 

            context.AuditLogs.Add(new AuditLog
            {
                AdminUserName = currentAdminName ?? "Unknown",
                Action = isCredit ? "Changed Credit Limit" : "Changed Max Payout",
                TargetUserName = userToUpdate.UserName ?? "Unknown",
                Details = logDetails
            });

            await context.SaveChangesAsync();
            
            await HubContext.Clients.Group("Admins").SendAsync("ReceiveAdminNotification", 
                $"{fieldName} updated for {userToUpdate.UserName}");
            
            successMessage = $"{fieldName} updated for {userToUpdate.UserName}!";
            
            await LoadUsers();
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
    }
}